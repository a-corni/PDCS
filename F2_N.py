import numpy as np
import sys

np.set_printoptions(threshold=sys.maxsize)

def tobinary(i, n):
   
    #convertir un int en une liste de 0 et de 1 de longueur n
    #i= a1*2**0+...+an*2**(n-1) s'écrit [a1,...,an] 
    
    binarystr = bin(i) 
    binarylist = []
   
    for j in range(len(binarystr)-1, 1, -1):
        binarylist.append(int(binarystr[j]))
    
    while len(binarylist)!=n :
        binarylist.append(0)
    
    return np.array(binarylist)

def F2_n(n):
    
    #sous-espace vectoriel de R^n dont les vecteurs ne contiennent que des O et des 1
    
    return [tobinary(i,n) for i in range(0,2**n)]

def Mn_F2(n):
    
    Base = []
    
    for i in range(n):
        
        for j in range(n):
        
            M = np.zeros((n,n),int)
            M[i,j]=1
            Base.append(M)
            
    MnF2 = []
    F2n2 = F2_n(n**2)
    
    for comblin in F2n2:
        
        M = np.zeros((n,n),int)
        
        for i in range(n**2):
            
            M += comblin[i]*Base[i]
    
        MnF2.append(M)
    
    return MnF2

def sev(A,B):
    
    #sous espace vectoriel engendré par les lignes de la matrice C=(A,B)
    #S = sum[1<=i<=n](ei*ci) où ci est la i-ème ligne de C et (ei) est dans {0,1}^n 
    #on a un ensemble de lignes en sortie
    
    set = []
    taille = np.shape(A)
    n = taille[0]
    F2n = F2_n(n)
    
    C = np.concatenate((A,B),axis=1)
    
    for comblin in F2n:

        #on parcourt les vecteurs (ei)
        
        row = np.zeros(2*n, int)
        
        for i in range(n):
            
            #on ajoute ei*ci 
            row += comblin[i]*C[i]
        
        set.append(row)
    
    set = np.remainder(set,2)
    
    return np.array(set)



def are_equivalent(M, N):
    
    # M, N are two matrices of Mnx2n(F2)
    # we want to know if they generate the same subspace
    # This happens if all the lines of N belong to the subspace generated by M and of the lines of M belong to the subspace generated by N
    
    equivalent = True
    taille = np.shape(M)
    n = taille[0]
    M1 = M[:,:n]
    M2 = M[:,n:]
    SM = sev(M1,M2)
    
    
    for generatorsN in N:
        iselementM = False
        for elements in SM :
            if np.array_equal(generatorsN,elements):
                iselementM=True
        if not iselementM :
            return False
           
    N1 = N[:,:n]
    N2 = N[:,n:]
    SN = sev(N1,N2)

    for generatorsM in M:
        iselementN = False
        for elements in SN :
            if np.array_equal(generatorsM,elements):
                iselementN=True
        if not iselementN :
            return False
    
    return True

def linear_subspace(n):
    
    linearsubspace = []
    MnF2 = Mn_F2(n)
    
    for A in MnF2 :
       
        for B in MnF2 :
    
            M = np.concatenate((A,B),axis=1)
    
            if np.rank(M) == n:
                
                hasappeared = False
                m = len(linearsubspace)
                
                for indexsubspace in range(m):
                    
                    subspace = linearsubspace[indexsubspace]
                    representant = subspace[0]
                    
                    if are_equivalent(M, representant):
                        linearsubspace[indexsubspace].append((A,B))
                        hasappeared = True
                
                if not hasappeared :
                    linearsubspace.append([M, (A,B)])
    
    return linearsubspace

def pauli_ordre_2(i,j):
    
    #les matrices de Pauli sont codées de manière binaire
    #00 : I
    #10 : X
    #01 : Y
    #11 : Z
    
    if i%2==0 and j%2==0:
        return 'I'
    elif i%2==1 and j%2==0 :
        return 'X'
    elif i%2==0 and j%2==1 :
        return 'Z'
    else :
        return 'Y'

def sub_pauli(A,B):
    
    #on traduit le sous-espace vectoriel engendré par les lignes de la matrice (A,B) en matrice de Pauli selon la fonction précédente
    set = sev(A,B)
    taille = np.shape(A)
    n = taille[0]
    paulisubset = []
    
    for row in set:
        
        #pour chaque ligne du sous-espace vectoriel
        #on définit une matrice de pauli à n qubit
        
        pauli_ordre_n = ''
        
        for i in range(n):
            
            #la ième matrice d'ordre 2 du n-qubit est donnée par les valeurs en position i et n+i de la ligne du sous-ensemble
            pauli_ordre_n += pauli_ordre_2(row[i],row[n+i])
        
        paulisubset.append(pauli_ordre_n)
    
    return paulisubset
    
def linear_subspace_understoodable(n):
    
    fichier = open("linear_subspace.txt", "w")
    linearsubspace = linear_subspace(n)
    understoodable = []
    
    for subspace in linearsubspace:
        
        n = len(subspace)
        (A,B) = subspace[1]
        subspacename = sub_pauli(A,B)
        understoodable.append(subspacename)
        fichier.write(str(subspacename) + "Il y a " + str(n-1)+ " matrices équivalentes :" +"\n")
        
        for i in range(1,n):
            
            understoodable.append(subspace[i])
            fichier.write(str(subspace[i]) + ", "+"\n")
        
        understoodable.append(n-1)
        fichier.write("\n")
    
    fichier.close()
    
    return understoodable